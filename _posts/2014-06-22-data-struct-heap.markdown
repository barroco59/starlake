---
layout: post
title:  "数据结构--堆"
date:   2014-06-22 03:11:39
categories: datastruct
---

### 堆
可以用一颗完全二叉树来描述
假设数组标记i从0到len-1，则
left[i]=2\*i+1;    right[i]=2\*i+2;
反过来：
i = (left-1)/2;    i = (right-1)/2; (i/left/right 取值范围为0到len-1；除2其实是向下取整)

### 堆排序算法描述
堆排序包括以下几个过程：
- 设计max-heap函数
该函数为关键辅助函数，假设当前处理节点为i，并假设i的两颗子树（如果存在） left[i],right[i]开始的数都是大顶堆（或小顶堆，具体看堆类型）
则max-heap函数会将节点i插入到子树中，使得满足大顶堆的性质。
通过计算可以得到该函数的复杂度为T(n)<=T(2/3n)+O(1) 化解后可得 时间复杂度为O(lgn)

- 构建堆
其实就是从最后一个节点的父节点开始，依次调用max-heap，从而构建成为整个堆

- 排序
>>
  1. 先构造堆
    2. 从最后一个元素开始，依次与第一个元素替换，每次替换之后（相当于把第一个元素放置到数组的最后位置），减小相应的数组大小（调整堆大小）,调用max-heap，重构堆（注意堆大小减少）
    由于需要调用依次max-heap n次，所以性能为O(nlgn)

## use case
- Q: 1百万个数中，找出最大的1000个数

A: 构造一个1000大小的小顶堆，依次添加，每次替换掉顶部最小的数据; 时间复杂度为O(klgn),k为需求的最大个数，n为数组长度

A:  也可以采用选择中位数的计算方法，可以达到O（n）的时间复杂度（该算法有使用快排轴选取的过程）

- 优先队列如何实现

使用最大堆（最大优先级）或最小堆（最小优先级）
区别在于，优先队列中可能会改变元素的优先级（即值改变），此时需要做调整，调整的方法也类似max-heap，有点逆推的过程，即更新一个值后，需要与该节点的父节点比较，如果满足堆性质，则不改变，否则需要调整，继续调整，直到没有可以调整的元素即可。

[starlake]:    http://starlakes.tk
